# AdveRSArial Crypto (Baby)

## Challenge
J'ai perfectionné mes connaissances sur RSA, mais je ne suis pas sûr que ma manière creuse de générer les nombres soit intelligente. Vous confirmez ?

## Inputs
- [output.txt](./output.txt)

## Analysis
The modulus factorization is unknown to `factordb`. Also, `RsaCtfTool` doesn't find an easy win.

Let's encode the public key in `PEM format`:
```console
$ ./RsaCtfTool.py --createpub  -n 179770685017248789197537661565815269934203562120851089179122414399064734715990794430000078278988633398024403072323955508476586487162411822366599111412534539430740137196265242371128714558362082882520001747685222655863817125733693411058452743768818267918688593648334613756045157321491607233744902053478170361857 -e 65537 --private > /tmp/pub.pem
$ cat /tmp/pub.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQEAAIAAAAAAAEAAAAAAAAAAAAAB
AAgABEIBIACAAgAAEAFAAIAACAAMAEBAARACAIACAAABAAAAAAoEAAAAEAACgABA
AAAAAAAgAAAAAAAgAAEABIAQAACBAgAEAAAAACACAAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAAgAAAAAAAQIDAQAB
-----END PUBLIC KEY-----
```

Then I noticed that the hexdecimal value for the modulus has a lot of zeros:
``` console
$ openssl rsa --in /tmp/pub.pem --pubin -text
Public-Key: (1025 bit)
Modulus:
    01:00:00:80:00:00:00:00:00:40:00:00:00:00:00:
    00:00:00:00:01:00:08:00:04:42:01:20:00:80:02:
    00:00:10:01:40:00:80:00:08:00:0c:00:40:40:01:
    10:02:00:80:02:00:00:01:00:00:00:00:0a:04:00:
    00:00:10:00:02:80:00:40:00:00:00:00:00:20:00:
    00:00:00:00:20:00:01:00:04:80:10:00:00:81:02:
    00:04:00:00:00:00:20:02:00:00:00:00:10:00:00:
    00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:
    00:00:02:00:00:00:00:00:01
Exponent: 65537 (0x10001)
writing RSA key
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQEAAIAAAAAAAEAAAAAAAAAAAAAB
AAgABEIBIACAAgAAEAFAAIAACAAMAEBAARACAIACAAABAAAAAAoEAAAAEAACgABA
AAAAAAAgAAAAAAAgAAEABIAQAACBAgAEAAAAACACAAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAAgAAAAAAAQIDAQAB
-----END PUBLIC KEY-----
```

Oh, but the challenge suggests something about holes in the numbers or something ?? Maybe that refers to all these zeros ?

## Play with different bases for the modulus
I came across this writeup about RSA modulus factorization where the modulus is evaluated in base 11: https://ctftime.org/writeup/22977

So I started looking at `the modulus in various bases` with `sage`:

```console
$ sage
(...)
sage: n = 1797706850172487891975376615658152699342035621208510891791224143990647347159907944300
....: 00078278988633398024403072323955508476586487162411822366599111412534539430740137196265242
....: 37112871455836208288252000174768522265586381712573369341105845274376881826791868859364833
....: 4613756045157321491607233744902053478170361857
sage: n.str(base=16)
'10000800000000000400000000000000000000100080004420120008002000010014000800008000c004040011002008002000001000000000a0400000010000280004000000000002000000000002000010004801000008102000400000000200200000000100000000000000000000000000000000000000002000000000001'
sage: poly = sum(e * x^i for i,e in enumerate(n.digits(16)))
sage: poly
x^256 + 8*x^251 + 4*x^239 + x^218 + 8*x^214 + 4*x^210 + 4*x^209 + 2*x^208 + x^206 + 2*x^205 + 8*x^201 + 2*x^198 + x^193 + x^190 + 4*x^189 + 8*x^185 + 8*x^180 + 12*x^176 + 4*x^173 + 4*x^171 + x^168 + x^167 + 2*x^164 + 8*x^161 + 2*x^158 + x^152 + 10*x^142 + 4*x^140 + x^133 + 2*x^128 + 8*x^127 + 4*x^123 + 2*x^111 + 2*x^99 + x^94 + 4*x^90 + 8*x^89 + x^87 + 8*x^81 + x^80 + 2*x^78 + 4*x^74 + 2*x^65 + 2*x^62 + x^53 + 2*x^12 + 1
sage: poly.factor()
x^256 + 8*x^251 + 4*x^239 + x^218 + 8*x^214 + 4*x^210 + 4*x^209 + 2*x^208 + x^206 + 2*x^205 + 8*x^201 + 2*x^198 + x^193 + x^190 + 4*x^189 + 8*x^185 + 8*x^180 + 12*x^176 + 4*x^173 + 4*x^171 + x^168 + x^167 + 2*x^164 + 8*x^161 + 2*x^158 + x^152 + 10*x^142 + 4*x^140 + x^133 + 2*x^128 + 8*x^127 + 4*x^123 + 2*x^111 + 2*x^99 + x^94 + 4*x^90 + 8*x^89 + x^87 + 8*x^81 + x^80 + 2*x^78 + 4*x^74 + 2*x^65 + 2*x^62 + x^53 + 2*x^12 + 1
sage: n.str(base=2)
'10000000000000000100000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000010000000000000000100010000100000000100100000000000001000000000000010000000000000000000010000000000010100000000000000100000000000000000001000000000000000110000000000010000000100000000000001000100000000001000000000100000000000001000000000000000000000000100000000000000000000000000000000000010100000010000000000000000000000000000010000000000000000001010000000000000000100000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000010000000000000000000010000000000000100100000000001000000000000000000001000000100000010000000000000010000000000000000000000000000000000001000000000001000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000001'
sage: poly = sum(e * x^i for i,e in enumerate(n.digits(2)))
sage: poly
x^1024 + x^1007 + x^958 + x^872 + x^859 + x^842 + x^838 + x^833 + x^824 + x^821 + x^807 + x^793 + x^772 + x^760 + x^758 + x^743 + x^723 + x^707 + x^706 + x^694 + x^686 + x^672 + x^668 + x^657 + x^647 + x^633 + x^608 + x^571 + x^569 + x^562 + x^532 + x^513 + x^511 + x^494 + x^445 + x^397 + x^376 + x^362 + x^359 + x^348 + x^327 + x^320 + x^313 + x^298 + x^261 + x^249 + x^212 + x^49 + 1
sage: poly.factor()
(x^513 + x^348 + x^327 + x^313 + x^249 + x^212 + 1)*(x^511 + x^494 + x^445 + x^359 + x^320 + x^49 + 1)
sage: (p, _), (q, _) = poly.factor_list()
sage: p, q = p(x=2), q(x=2)
sage: p
26815615859885194199148049996411692254958731641185360130374543433318025388027501869461427030990935414084875128479962203391492343065290316985075546168754177
sage: q
6703955111699546927094586295728886856295101772488437969932374169355084483139592121732447937761581686389247431572954518413208217084020226417145371521187841
sage: p*q
179770685017248789197537661565815269934203562120851089179122414399064734715990794430000078278988633398024403072323955508476586487162411822366599111412534539430740137196265242371128714558362082882520001747685222655863817125733693411058452743768818267918688593648334613756045157321491607233744902053478170361857
sage: n
179770685017248789197537661565815269934203562120851089179122414399064734715990794430000078278988633398024403072323955508476586487162411822366599111412534539430740137196265242371128714558362082882520001747685222655863817125733693411058452743768818267918688593648334613756045157321491607233744902053478170361857
```

Allright, so we can express the modulus in base 2, then build a polynomial which `sage` can factorize. Evaluating these polynomials at `x=2` gives us the primes !

## Solution
Now we can implement the same thing in python, recover the primes `p, q`, then perform the usual `RSA decryption`: compute `phi`, `d` and recover the plaintext. Implemented in [sol.py](./sol.py):

```python
from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes, bytes_to_long
from sage.all import *
from sage.calculus.predefined import x

n = 179770685017248789197537661565815269934203562120851089179122414399064734715990794430000078278988633398024403072323955508476586487162411822366599111412534539430740137196265242371128714558362082882520001747685222655863817125733693411058452743768818267918688593648334613756045157321491607233744902053478170361857
e = 65537
c = 0x000c307feca4371acecab2690800586b967909e12ec3e80184666ca161129f86c6cd87e276127a1f9b672b66ba3d715321b24f7d660a928d829c154dcdc0634b99f51e281c2e138f77a04694ff7aeec25c938cf769fbd7d3f2968f0b96fc5d38a8f742f6a46e70d7eae8280ed61f0328df36497f0cb6251b0e13a2bc5adce6344a

base = 2
poly = sum(e * x**i for i,e in enumerate(Integer(n).digits(base)))
(p, _), (q, _) = poly.factor_list()
p, q = p(x=base), q(x=base)
assert p*q == n

d = inverse_mod(e, (p-1)*(q-1))
print(long_to_bytes(pow(c, d, n)))
```

```console
$ sage sol.py
b"\x02mF\x03\xb9\xe6(s\xb5\xd0\x88\xdd\xdc|N\n\xbbr\xb8~\x0cI\xce\xea{'\xc8\x7f\x1eS\x8dz\xbcf\x87\xb0\n+\xf2\x19=\x0f3\xef\xa8M'\x8f\x02}\xb8\x07\xee\xe7\xb3\\\xbd\x00FCSC{0224e979da8a6069869ccfc040abb680ffd35e3ba61bcc0e0683662c33fa81c0}"
```

# Flag
> FCSC{0224e979da8a6069869ccfc040abb680ffd35e3ba61bcc0e0683662c33fa81c0}
